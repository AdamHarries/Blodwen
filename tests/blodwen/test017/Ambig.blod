module Ambig

-- Make sure we can overload >>= correctly, and still use the Prelude one

data State : Type -> Type where
     Get : State a
     Put : a -> State ()

data Thing : Type -> Type where
     Pure : a -> Thing a
     Bind : Thing a -> (a -> Thing b) -> Thing b
     Op : State a -> Thing a

Do Thing where
   Next a x = {b : Type} -> (a -> Thing b) -> Thing b
   x >>= k = Bind x k

stateProg : Int -> Thing Int
stateProg x
    = do Op (Put x)
         x <- Op Get
         Pure x

foo : Maybe Int -> Maybe Int -> Maybe Int
foo x y 
    = do x' <- x
         y' <- y
         Just (x' + y')

bar : Maybe Int -> Maybe Int -> Maybe (Thing Int)
bar x y
    = do x' <- x
         y' <- y
         pure (do Op (Put x')
                  x <- Op Get
                  Pure x)
