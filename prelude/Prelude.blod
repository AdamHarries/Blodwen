module Prelude

import public Builtin
import public PrimIO

{-
The Prelude is minimal (since it is effectively part of the language 
specification, this seems to be desirable - we should, nevertheless, aim to
provide a good selection of base libraries).

As such, it should contain:

- Anything the elaborator can desugar to (e.g. pairs, unit, =, laziness)
- Basic types Bool, Nat, List, Dec, Maybe, Either
- The most important utility functions: id, the, composition, etc
- Interfaces for arithmetic and implementations for the primitives and
  basic types
- Show, Eq, Ord, and implementations for all types in the prelude
- Interfaces and functions for basic proof (cong, Uninhabited, etc)
- [Possibly Enum for range syntax?]
- Semigroup, Monoid
- Functor, Applicative, Monad and related functions
- Foldable, Traversable
- Basic interaction (Console and File IO)

Everything else should be in the base libraries, and imported as required.
In particular, proofs of Nat/List properties that almost never get used in
practice would probably be better in base libraries.

(These guidelines will probably get revised a few times.)
-}

-- Numerical operators
infix 6 ==, /=, <, <=, >, >=
infixl 7 <<, >> -- unused
infixl 8 +, -
infixl 9 *, /

-- Boolean operators
infixr 4 &&
infixr 5 ||

-- List and String operators
infixr 7 ::, ++

-- Functor/Applicative/Monad/Algebra operators
infixl 1 >>=
infixl 3 <*>
infixr 4 <$>
infixl 6 <+>

-- Utility operators
infixr 9 .
infixr 0 $

-- Can't do this syntax yet: infixl 9 `div`, `mod`

-----------------------
-- UTILITY FUNCTIONS --
-----------------------

public export
the : (0 a : Type) -> a -> a
the _ x = x

public export
id : a -> a
id x = x

public export
const : a -> b -> a
const x = \value => x

public export
(.) : (b -> c) -> (a -> b) -> a -> c
(.) f g = \x => f (g x)

public export
flip : (f : a -> b -> c) -> b -> a -> c
flip f x y = f y x

public export
apply : (a -> b) -> a -> b
apply f a = f a

-------------------
-- PROOF HELPERS --
-------------------

public export
cong : {0 f : t -> u} -> a = b -> f a = f b
cong Refl = Refl

public export
interface Uninhabited t where
  uninhabited : t -> Void

%extern
public export
void : Void -> a

public export
absurd : Uninhabited t => (h : t) -> a
absurd h = void (uninhabited h)

--------------
-- BOOLEANS --
--------------

public export
data Bool = True | False

public export
not : Bool -> Bool
not True = False
not False = True

public export
(&&) : Bool -> Lazy Bool -> Bool
(&&) True x = x
(&&) False x = False

public export
(||) : Bool -> Lazy Bool -> Bool
(||) True x = True
(||) False x = x

------------------------
-- NUMERIC INTERFACES --
------------------------

public export
interface Num ty where
    (+) : ty -> ty -> ty
    (*) : ty -> ty -> ty
    fromInteger : Integer -> ty

public export
Num Integer where
    (+) = prim__add_Integer
    (*) = prim__mul_Integer
    fromInteger = id

-- This allows us to pick integer as a default at the end of elaboration if
-- all other possibilities fail. I don't plan to provide a nicer syntax for
-- this...
%defaulthint
public export
defaultInteger : Num Integer
defaultInteger = %search

public export
Num Int where
    (+) = prim__add_Int
    (*) = prim__mul_Int
    fromInteger = prim__cast_IntegerInt

public export
Num Double where
    (+) = prim__add_Double
    (*) = prim__mul_Double
    fromInteger = prim__cast_IntegerDouble

public export
intToBool : Int -> Bool
intToBool 0 = False
intToBool x = True

-------------
-- ALGEBRA --
-------------

public export
interface Semigroup ty where
    (<+>) : ty -> ty -> ty

public export
interface Semigroup ty => Monoid ty where
    neutral : ty

------------------------
-- EQUALITY, ORDERING --
------------------------

public export
interface Eq ty where
  (==) : ty -> ty -> Bool
  (/=) : ty -> ty -> Bool

  x == y = not (x /= y)
  x /= y = not (x == y)

public export
Eq () where
  _ == _ = True

public export
Eq Bool where
  True == True = True
  False == False = False

public export
Eq Int where
  x == y = intToBool (prim__eq_Int x y)

public export
Eq Integer where
  x == y = intToBool (prim__eq_Integer x y)

public export
Eq Double where
  x == y = intToBool (prim__eq_Double x y)

public export
Eq Char where
  x == y = intToBool (prim__eq_Char x y)

public export
Eq String where
  x == y = intToBool (prim__eq_String x y)

public export
Eq a => Eq b => Eq (a, b) where
  (x1, y1) == (x2, y2) = x1 == x2 && y1 == y2

public export
data Ordering = LT | EQ | GT

public export
Eq Ordering where
    LT == LT = True
    EQ == EQ = True
    GT == GT = True
    _  == _  = False

public export
interface Eq ty => Ord ty where
    constructor MkOrd

    compare : ty -> ty -> Ordering

    (<) : ty -> ty -> Bool
    (<) x y = compare x y == LT
    
    (>) : ty -> ty -> Bool
    (>) x y = compare x y == GT

    (<=) : ty -> ty -> Bool
    (<=) x y = compare x y /= GT

    (>=) : ty -> ty -> Bool
    (>=) x y = compare x y /= LT

    max : ty -> ty -> ty
    max x y = if x > y then x else y

    min : ty -> ty -> ty
    min x y = if (x < y) then x else y

public export
Ord () where
  compare _ _ = EQ

public export
Ord Bool where
  compare False False = EQ
  compare False True = LT
  compare True False = GT
  compare True True = EQ

public export
Ord Int where
  compare x y = if x < y then LT else if x == y then EQ else GT

  (<) x y = intToBool (prim__lt_Int x y)
  (<=) x y = intToBool (prim__lte_Int x y)
  (>) x y = intToBool (prim__gt_Int x y)
  (>=) x y = intToBool (prim__gte_Int x y)

public export
Ord Integer where
  compare x y = if x < y then LT else if x == y then EQ else GT

  (<) x y = intToBool (prim__lt_Integer x y)
  (<=) x y = intToBool (prim__lte_Integer x y)
  (>) x y = intToBool (prim__gt_Integer x y)
  (>=) x y = intToBool (prim__gte_Integer x y)

public export
Ord Double where
  compare x y = if x < y then LT else if x == y then EQ else GT

  (<) x y = intToBool (prim__lt_Double x y)
  (<=) x y = intToBool (prim__lte_Double x y)
  (>) x y = intToBool (prim__gt_Double x y)
  (>=) x y = intToBool (prim__gte_Double x y)

public export
Ord String where
  compare x y = if x < y then LT else if x == y then EQ else GT

  (<) x y = intToBool (prim__lt_String x y)
  (<=) x y = intToBool (prim__lte_String x y)
  (>) x y = intToBool (prim__gt_String x y)
  (>=) x y = intToBool (prim__gte_String x y)

public export
Ord Char where
  compare x y = if x < y then LT else if x == y then EQ else GT

  (<) x y = intToBool (prim__lt_Char x y)
  (<=) x y = intToBool (prim__lte_Char x y)
  (>) x y = intToBool (prim__gt_Char x y)
  (>=) x y = intToBool (prim__gte_Char x y)

public export
Ord a => Ord b => Ord (a, b) where
  compare (x1, y1) (x2, y2)
      = if x1 /= x2 then compare x1 x2
                    else compare y1 y2

---------------------------------
-- FUNCTOR, APPLICATIVE, MONAD --
---------------------------------

public export
interface Functor f where
    map : (a -> b) -> f a -> f b

public export
(<$>) : Functor f => (func : a -> b) -> f a -> f b
(<$>) func x = map func x

public export
interface Functor f => Applicative f where
    pure : a -> f a
    (<*>) : f (a -> b) -> f a -> f b

public export
interface Applicative m => Monad m where
    (>>=) : m a -> (a -> m b) -> m b
    join : m (m a) -> m a

    -- default implementations
    (>>=) x f = join (f <$> x)
    join x = x >>= id

---------------------------
-- FOLDABLE, TRAVERSABLE --
---------------------------

public export
interface Foldable (t : Type -> Type) where
  foldr : (func : elem -> acc -> acc) -> (init : acc) -> (input : t elem) -> acc
  foldl : (func : acc -> elem -> acc) -> (init : acc) -> (input : t elem) -> acc
  foldl f z t = foldr (flip (.) . flip f) id t z

public export
concat : (Foldable t, Monoid a) => t a -> a
concat = foldr (<+>) neutral

public export
concatMap : (Foldable t, Monoid m) => (a -> m) -> t a -> m
concatMap f = foldr ((<+>) . f) neutral

public export
and : Foldable t => t (Lazy Bool) -> Bool
and = foldl (&&) True

public export
or : Foldable t => t (Lazy Bool) -> Bool
or = foldl (||) False

public export
any : Foldable t => (a -> Bool) -> t a -> Bool
any p = foldl (\x,y => x || p y) False

public export
all : Foldable t => (a -> Bool) -> t a -> Bool
all p = foldl (\x,y => x && p y)  True

public export
sum : (Foldable t, Num a) => t a -> a
sum = foldr (+) (fromInteger 0)

public export
product : (Foldable t, Num a) => t a -> a
product = foldr (*) (fromInteger 1)

-----------
-- NATS ---
-----------

public export
data Nat = Z | S Nat

public export
Num Nat where
  Z + y = y
  S k + y = S (k + y)

  Z * y = Z
  S k * y = y + k * y

  fromInteger x = if intToBool (prim__eq_Integer x 0)
                     then Z else
                          S (fromInteger (prim__sub_Integer x 1))

public export
Eq Nat where
  Z == Z = True
  S j == S k = j == k
  _ == _ = False

public export
Ord Nat where
  compare Z Z = EQ
  compare Z (S k) = LT
  compare (S k) Z = GT
  compare (S j) (S k) = compare j k

-------------
-- STRINGS --
-------------

namespace Strings
    public export
    (++) : String -> String -> String
    x ++ y = prim__strAppend x y

public export
length : String -> Nat
length str = fromInteger (prim__cast_IntInteger (prim__strLength str))

public export
reverse : String -> String
reverse = prim__strReverse

-----------
-- MAYBE --
-----------

public export
data Maybe : (ty : Type) -> Type where
    Nothing : Maybe ty
    Just : (1 x : ty) -> Maybe ty

public export
maybe : Lazy b -> Lazy (a -> b) -> Maybe a -> b
maybe n j Nothing  = n
maybe {a} {b} n j (Just x) = j x

public export
Eq a => Eq (Maybe a) where
  Nothing  == Nothing  = True
  Nothing  == (Just _) = False
  (Just _) == Nothing  = False
  (Just a) == (Just b) = a == b

public export
Ord a => Ord (Maybe a) where
  compare Nothing  Nothing  = EQ
  compare Nothing  (Just _) = LT
  compare (Just _) Nothing  = GT
  compare (Just a) (Just b) = compare a b

public export
Semigroup (Maybe a) where
  Nothing   <+> m = m
  (Just x)  <+> _ = Just x

public export
Monoid (Maybe a) where
  neutral = Nothing

public export
Functor Maybe where
    map f (Just x) = Just (f x)
    map f Nothing  = Nothing

public export
Applicative Maybe where
    pure = Just

    (Just f) <*> (Just a) = Just (f a)
    _        <*> _        = Nothing

public export
Monad Maybe where
    Nothing  >>= k = Nothing
    (Just x) >>= k = k x

public export
Foldable Maybe where
  foldr _ z Nothing  = z
  foldr f z (Just x) = f x z

-----------
-- LISTS --
-----------

public export
data List a = Nil | (::) a (List a)

public export
Eq a => Eq (List a) where
  [] == [] = True
  x :: xs == y :: ys = x == y && xs == ys

public export
Ord a => Ord (List a) where
  compare [] (x :: xs) = LT
  compare (x :: xs) [] = GT
  compare (x :: xs) (y ::ys) 
     = case compare x y of
            EQ => compare xs ys
            c => c

namespace List
    public export
    (++) : List a -> List a -> List a
    [] ++ ys = ys
    (x :: xs) ++ ys = x :: xs ++ ys

public export
Functor List where
  map f [] = []
  map f (x :: xs) = f x :: map f xs

public export
Semigroup (List a) where
  (<+>) = (++)

public export
Monoid (List a) where
  neutral = []

public export
Foldable List where
  foldr c n [] = n
  foldr c n (x::xs) = c x (foldr c n xs)

  foldl f q [] = q
  foldl f q (x::xs) = foldl f (f q x) xs

public export
Applicative List where
  pure x = [x]
  fs <*> vs = concatMap (\f => map f vs) fs

public export
Monad List where
  m >>= f = concatMap f m

----------
-- SHOW --
----------

public export
data Prec = Open | Equal | Dollar | Backtick | User Nat | PrefixMinus | App

public export
precCon : Prec -> Integer
precCon Open        = 0
precCon Equal       = 1
precCon Dollar      = 2
precCon Backtick    = 3
precCon (User n)    = 4
precCon PrefixMinus = 5
precCon App         = 6

public export
interface Show ty where
  show : (x : ty) -> String
  show x = showPrec Open x

  showPrec : (d : Prec) -> (x : ty) -> String
  showPrec _ x = show x

--------
-- IO --
--------

public export
Functor IO where
  map f io = io_bind io (\b => io_pure (f b))

public export
Applicative IO where
    pure x = io_pure x
    f <*> a = io_bind f (\f' =>
                io_bind a (\a' =>
                  io_pure (f' a')))

public export
Monad IO where
    b >>= k = io_bind b k

export
print : Show a => a -> IO ()
print x = putStr (show x)

export
printLn : Show a => a -> IO ()
printLn x = putStrLn (show x)


