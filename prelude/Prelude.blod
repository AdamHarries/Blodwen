module Prelude

import public Builtin
import public PrimIO

{-
The Prelude is minimal (since it is effectively part of the language 
specification, this seems to be desirable - we should, nevertheless, aim to
provide a good selection of base libraries).

As such, it should contain:

- Anything the elaborator can desugar to (e.g. pairs, unit, =, laziness)
- Basic types Bool, Nat, List, Dec, Maybe, Either
- The most important utility functions: id, the, composition, etc
- Interfaces for arithmetic and implementations for the primitives and
  basic types
- Show, Eq, Ord, and implementations for all types in the prelude
- Interfaces and functions for basic proof (cong, Uninhabited, etc)
- [Possibly Enum for range syntax?]
- Semigroup, Monoid
- Functor, Applicative, Monad and related functions
- Foldable, Traversable
- Basic interaction (Console and File IO)

Everything else should be in the base libraries, and imported as required.
In particular, proofs of Nat/List properties that almost never get used in
practice would probably be better in base libraries.

(These guidelines will probably get revised a few times.)
-}

-- Numerical operators
infix 6 ==, /=, <, <=, >, >=
infixl 7 <<, >> -- unused
infixl 8 +, -
infixl 9 *, /

-- Boolean operators
infixr 4 &&
infixr 5 ||

-- List and String operators
infixr 7 ::, ++

-- Applicative/Monad operators
infixl 1 >>=
infixl 3 <*>
infixr 4 <$>

-- Utility operators
infixr 9 .
infixr 0 $

-- Can't do this syntax yet: infixl 9 `div`, `mod`

-----------------------
-- UTILITY FUNCTIONS --
-----------------------

public export
the : (0 a : Type) -> a -> a
the _ x = x

public export
id : a -> a
id x = x

public export
const : a -> b -> a
const x = \value => x

public export
(.) : (b -> c) -> (a -> b) -> a -> c
(.) f g = \x => f (g x)

public export
flip : (f : a -> b -> c) -> b -> a -> c
flip f x y = f y x

public export
apply : (a -> b) -> a -> b
apply f a = f a

-------------------
-- PROOF HELPERS --
-------------------

public export
cong : {0 f : t -> u} -> a = b -> f a = f b
cong Refl = Refl

public export
interface Uninhabited t where
  uninhabited : t -> Void

%extern
public export
void : Void -> a

public export
absurd : Uninhabited t => (h : t) -> a
absurd h = void (uninhabited h)

--------------
-- BOOLEANS --
--------------

public export
data Bool = True | False

public export
not : Bool -> Bool
not True = False
not False = True

public export
(&&) : Bool -> Lazy Bool -> Bool
(&&) True x = x
(&&) False x = False

public export
(||) : Bool -> Lazy Bool -> Bool
(||) True x = True
(||) False x = x

------------------------
-- NUMERIC INTERFACES --
------------------------

public export
interface Num ty where
    (+) : ty -> ty -> ty
    (*) : ty -> ty -> ty
    fromInteger : Integer -> ty

public export
Num Integer where
    (+) = prim__add_Integer
    (*) = prim__mul_Integer
    fromInteger = id

-- This allows us to pick integer as a default at the end of elaboration if
-- all other possibilities fail. I don't plan to provide a nicer syntax for
-- this...
%defaulthint
public export
defaultInteger : Num Integer
defaultInteger = %search

public export
Num Int where
    (+) = prim__add_Int
    (*) = prim__mul_Int
    fromInteger = prim__cast_IntegerInt

public export
Num Double where
    (+) = prim__add_Double
    (*) = prim__mul_Double
    fromInteger = prim__cast_IntegerDouble

public export
intToBool : Int -> Bool
intToBool 0 = False
intToBool x = True

-------------
-- ALGEBRA --
-------------

interface Semigroup ty where
    (<+>) : ty -> ty -> ty

interface Semigroup ty => Monoid ty where
    neutral : ty

---------------------------------
-- FUNCTOR, APPLICATIVE, MONAD --
---------------------------------

interface Functor f where
    map : (a -> b) -> f a -> f b

(<$>) : Functor f => (func : a -> b) -> f a -> f b
(<$>) func x = map func x

interface Functor f => Applicative f where
    pure : a -> f a
    (<*>) : f (a -> b) -> f a -> f b

interface Applicative m => Monad m where
    (>>=) : m a -> (a -> m b) -> m b
    join : m (m a) -> m a

    -- default implementations
    (>>=) x f = join (f <$> x)
    join x = x >>= id

---------------------------
-- FOLDABLE, TRAVERSABLE --
---------------------------

interface Foldable (t : Type -> Type) where
  foldr : (func : elem -> acc -> acc) -> (init : acc) -> (input : t elem) -> acc
  foldl : (func : acc -> elem -> acc) -> (init : acc) -> (input : t elem) -> acc
  foldl f z t = foldr (flip (.) . flip f) id t z

concat : (Foldable t, Monoid a) => t a -> a
concat = foldr (<+>) neutral

concatMap : (Foldable t, Monoid m) => (a -> m) -> t a -> m
concatMap f = foldr ((<+>) . f) neutral

and : Foldable t => t (Lazy Bool) -> Bool
and = foldl (&&) True

or : Foldable t => t (Lazy Bool) -> Bool
or = foldl (||) False

any : Foldable t => (a -> Bool) -> t a -> Bool
any p = foldl (\x,y => x || p y) False

all : Foldable t => (a -> Bool) -> t a -> Bool
all p = foldl (\x,y => x && p y)  True

sum : (Foldable t, Num a) => t a -> a
sum = foldr (+) (fromInteger 0)

product : (Foldable t, Num a) => t a -> a
product = foldr (*) (fromInteger 1)

-----------
-- NATS ---
-----------

public export
data Nat = Z | S Nat

public export
Num Nat where
  Z + y = y
  S k + y = S (k + y)

  Z * y = Z
  S k * y = y + k * y

  fromInteger x = if intToBool (prim__eq_Integer x 0)
                     then Z else
                          S (fromInteger (prim__sub_Integer x 1))

-------------
-- STRINGS --
-------------

namespace Strings
    public export
    (++) : String -> String -> String
    x ++ y = prim__strAppend x y

public export
length : String -> Nat
length str = fromInteger (prim__cast_IntInteger (prim__strLength str))

public export
reverse : String -> String
reverse = prim__strReverse

-----------
-- LISTS --
-----------

public export
data List a = Nil | (::) a (List a)

namespace List
    public export
    (++) : List a -> List a -> List a
    [] ++ ys = ys
    (x :: xs) ++ ys = x :: xs ++ ys

Functor List where
  map f [] = []
  map f (x :: xs) = f x :: map f xs

