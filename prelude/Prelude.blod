module Prelude

import public Builtin
import public PrimIO

{-
The Prelude is minimal (since it is effectively part of the language 
specification, this seems to be desirable - we should, nevertheless, aim to
provide a good selection of base libraries).

As such, it should contain:

- Anything the elaborator can desugar to (e.g. pairs, unit, =, laziness)
- Basic types Bool, Nat, List, Dec, Maybe, Either
- The most important utility functions: id, the, composition, etc
- Interfaces for arithmetic and implementations for the primitives and
  basic types
- Show, Eq, Ord, and implementations for all types in the prelude
- Interfaces and functions for basic proof (cong, Uninhabited, etc)
- [Possibly Enum for range syntax?]
- Semigroup, Monoid
- Functor, Applicative, Monad and related functions
- Foldable, Traversable
- Basic interaction (Console and File IO)

Everything else should be in the base libraries, and imported as required.
In particular, proofs of Nat/List properties that almost never get used in
practice would probably be better in base libraries.

(These guidelines will probably get revised a few times.)
-}

-- Numerical operators
infix 6 ==, /=, <, <=, >, >=
infixl 7 <<, >> -- unused
infixl 8 +, -
infixl 9 *, /

-- Boolean operators
infixr 4 &&
infixr 5 ||

-- List and String operators
infixr 7 ::, ++

-- Applicative/Monad operators
infixl 1 >>=
infixl 3 <*>
infixr 4 <$>

-- Utility operators
infixr 9 .
infixr 0 $

-- Can't do this syntax yet: infixl 9 `div`, `mod`

-----------------------
-- UTILITY FUNCTIONS --
-----------------------

public export
the : (0 a : Type) -> a -> a
the _ x = x

public export
id : a -> a
id x = x

public export
const : a -> b -> a
const x = \value => x

public export
(.) : (b -> c) -> (a -> b) -> a -> c
(.) f g = \x => f (g x)

public export
flip : (f : a -> b -> c) -> b -> a -> c
flip f x y = f y x

public export
apply : (a -> b) -> a -> b
apply f a = f a

-------------------
-- PROOF HELPERS --
-------------------

public export
cong : {0 f : t -> u} -> a = b -> f a = f b
cong Refl = Refl

public export
interface Uninhabited t where
  uninhabited : t -> Void

%extern
public export
void : Void -> a

public export
absurd : Uninhabited t => (h : t) -> a
absurd h = void (uninhabited h)

--------------
-- BOOLEANS --
--------------

public export
data Bool = True | False

public export
not : Bool -> Bool
not True = False
not False = True

public export
(&&) : Bool -> Lazy Bool -> Bool
(&&) True x = x
(&&) False x = False

public export
(||) : Bool -> Lazy Bool -> Bool
(||) True x = True
(||) False x = x

------------------------
-- NUMERIC INTERFACES --
------------------------

public export
interface Num ty where
    (+) : ty -> ty -> ty
    (*) : ty -> ty -> ty
    fromInteger : Integer -> ty

public export
Num Integer where
    (+) = prim__add_Integer
    (*) = prim__mul_Integer
    fromInteger = id

-- This allows us to pick integer as a default at the end of elaboration if
-- all other possibilities fail. I don't plan to provide a nicer syntax for
-- this...
%defaulthint
public export
defaultInteger : Num Integer
defaultInteger = %search

public export
Num Int where
    (+) = prim__add_Int
    (*) = prim__mul_Int
    fromInteger = prim__cast_IntegerInt

public export
Num Double where
    (+) = prim__add_Double
    (*) = prim__mul_Double
    fromInteger = prim__cast_IntegerDouble

public export
intToBool : Int -> Bool
intToBool 0 = False
intToBool x = True

-------------
-- ALGEBRA --
-------------

public export
interface Semigroup ty where
    (<+>) : ty -> ty -> ty

public export
interface Semigroup ty => Monoid ty where
    neutral : ty

------------------------
-- EQUALITY, ORDERING --
------------------------

public export
interface Eq ty where
  (==) : ty -> ty -> Bool
  (/=) : ty -> ty -> Bool

  x == y = not (x /= y)
  x /= y = not (x == y)

public export
data Ordering = LT | EQ | GT

public export
Eq Ordering where
    LT == LT = True
    EQ == EQ = True
    GT == GT = True
    _  == _  = False

public export
interface Eq ty => Ord ty where
    constructor MkOrd

    compare : ty -> ty -> Ordering

    (<) : ty -> ty -> Bool
    (<) x y = compare x y == LT
    
    (>) : ty -> ty -> Bool
    (>) x y = compare x y == GT

    (<=) : ty -> ty -> Bool
    (<=) x y = compare x y /= GT

    (>=) : ty -> ty -> Bool
    (>=) x y = compare x y /= LT

    max : ty -> ty -> ty
    max x y = if x > y then x else y

    min : ty -> ty -> ty
    min x y = if (x < y) then x else y

---------------------------------
-- FUNCTOR, APPLICATIVE, MONAD --
---------------------------------

public export
interface Functor f where
    map : (a -> b) -> f a -> f b

public export
(<$>) : Functor f => (func : a -> b) -> f a -> f b
(<$>) func x = map func x

public export
interface Functor f => Applicative f where
    pure : a -> f a
    (<*>) : f (a -> b) -> f a -> f b

public export
interface Applicative m => Monad m where
    (>>=) : m a -> (a -> m b) -> m b
    join : m (m a) -> m a

    -- default implementations
    (>>=) x f = join (f <$> x)
    join x = x >>= id

---------------------------
-- FOLDABLE, TRAVERSABLE --
---------------------------

public export
interface Foldable (t : Type -> Type) where
  foldr : (func : elem -> acc -> acc) -> (init : acc) -> (input : t elem) -> acc
  foldl : (func : acc -> elem -> acc) -> (init : acc) -> (input : t elem) -> acc
  foldl f z t = foldr (flip (.) . flip f) id t z

public export
concat : (Foldable t, Monoid a) => t a -> a
concat = foldr (<+>) neutral

public export
concatMap : (Foldable t, Monoid m) => (a -> m) -> t a -> m
concatMap f = foldr ((<+>) . f) neutral

public export
and : Foldable t => t (Lazy Bool) -> Bool
and = foldl (&&) True

public export
or : Foldable t => t (Lazy Bool) -> Bool
or = foldl (||) False

public export
any : Foldable t => (a -> Bool) -> t a -> Bool
any p = foldl (\x,y => x || p y) False

public export
all : Foldable t => (a -> Bool) -> t a -> Bool
all p = foldl (\x,y => x && p y)  True

public export
sum : (Foldable t, Num a) => t a -> a
sum = foldr (+) (fromInteger 0)

public export
product : (Foldable t, Num a) => t a -> a
product = foldr (*) (fromInteger 1)

-----------
-- NATS ---
-----------

public export
data Nat = Z | S Nat

public export
Num Nat where
  Z + y = y
  S k + y = S (k + y)

  Z * y = Z
  S k * y = y + k * y

  fromInteger x = if intToBool (prim__eq_Integer x 0)
                     then Z else
                          S (fromInteger (prim__sub_Integer x 1))

public export
Eq Nat where
  Z == Z = True
  S j == S k = j == k
  _ == _ = False

public export
Ord Nat where
  compare Z Z = EQ
  compare Z (S k) = LT
  compare (S k) Z = GT
  compare (S j) (S k) = compare j k

-------------
-- STRINGS --
-------------

namespace Strings
    public export
    (++) : String -> String -> String
    x ++ y = prim__strAppend x y

public export
length : String -> Nat
length str = fromInteger (prim__cast_IntInteger (prim__strLength str))

public export
reverse : String -> String
reverse = prim__strReverse

-----------
-- LISTS --
-----------

public export
data List a = Nil | (::) a (List a)

namespace List
    public export
    (++) : List a -> List a -> List a
    [] ++ ys = ys
    (x :: xs) ++ ys = x :: xs ++ ys

public export
Functor List where
  map f [] = []
  map f (x :: xs) = f x :: map f xs

public export
Semigroup (List a) where
  (<+>) = (++)

public export
Monoid (List a) where
  neutral = []

public export
Foldable List where
  foldr c n [] = n
  foldr c n (x::xs) = c x (foldr c n xs)

  foldl f q [] = q
  foldl f q (x::xs) = foldl f (f q x) xs

public export
Applicative List where
  pure x = [x]
  fs <*> vs = concatMap (\f => map f vs) fs

----------
-- SHOW --
----------

public export
data Prec = Open | Equal | Dollar | Backtick | User Nat | PrefixMinus | App

public export
precCon : Prec -> Integer
precCon Open        = 0
precCon Equal       = 1
precCon Dollar      = 2
precCon Backtick    = 3
precCon (User n)    = 4
precCon PrefixMinus = 5
precCon App         = 6

interface Show ty where
  show : (x : ty) -> String
  show x = showPrec Open x

  showPrec : (d : Prec) -> (x : ty) -> String
  showPrec _ x = show x

